<p>
    The design of the nexml schema is guided by a handful of simple principles.
    Having some understanding of what these are will help you make the most of
    the documentation. You will want to find out how inheritance is used in the
    schema and how to traverse the inheritance tree, how nexml elements are
    nested, and how the schema is modularized into files. By reading this section, 
    you will learn the organization of the schema files and the type definitions 
    in them so you will be able to find what you need quickly.
</p>
<p>
    <img style="float:right; margin-left: 1em" src="http://farm1.static.flickr.com/153/434873145_1a1ba5c0e7_m.jpg" alt="A photo of a Russian Doll" />
    <strong>Babushka</strong> &mdash; Xml schemas generally are designed following 
    one of three patterns. If you sit down and design a schema for a rigid 
    format where things only ever have one place, you might start by writing the 
    type definition of the root element. Inside that type definition you would 
    define which child elements are allowed, and inside them you would define their 
    children and so on. 
</p>    
<p>    
    The end result would be a schema that mirrors the 
    instance documents you had in mind - one big nested structure. This is 
    known as the "Russian Doll" pattern. The downside of this approach is that you 
    can't break your schema down into different files or reuse type definitions so it
    is not a very practical approach for large schemas. This is <em>not</em> 
    how nexml is designed.
</p>
<p>
    <img style="float:left; margin-right: 1em" src="http://farm1.static.flickr.com/68/202460831_7eff36af23_m.jpg" alt="A photo of a Baloney sandwich" />
    <strong>Bologna</strong> &mdash; The second approach is the very opposite of 
    the first. You might take this approach if what you are building is a loosely 
    coupled collection of snippets, for example because each of them is a type of 
    small message you send to a web service. Following this design you would write 
    your schema as a library of type definitions and elements. 
</p>    
<p>     
    Although this is useful for messaging protocols and the like, it's not very 
    practical for complex structured data because every type can be the root element 
    and there isn't an obvious superstructure. Phylogenetic data like that 
    contained in NEXUS files consists of blocks of fundamentally different types that
    relate to each other in different ways. To make sense of these relationships
    and process and query them efficiently things need to be in predictable locations 
    within documents (or streams, records, or messages). The nexml schema is therefore
    also <em>not</em> designed following this "Salami Slice" pattern.
</p>
<p>
    <img style="float:right; margin-left: 1em" src="http://farm1.static.flickr.com/128/407906927_ebb76cc2b6_m.jpg" alt="A photo of Venetian blinds" />
    <strong>Venice</strong> &mdash; The third approach is an intermediate of the 
    two. Types are defined as a library of snippets just like the Salami Slice 
    pattern and exist as reusable, named, things - but they indicate what other 
    named types their immediate children can be. 
</p>    
<p>    
    Taken as a whole, such a design has a superstructure where one type slides 
    into another, and that into another, like the lattices in blinds: the "Venetian 
    Blinds" pattern, which is how nexml is designed. The basic units in the nexml
    schema are <a href="http://www.w3.org/TR/xmlschema-1/#Complex_Type_Definitions">complexType</a>
    definitions. These definitions consist of a clump of
    <a href="http://www.w3.org/TR/xmlschema-1/#cElement_Declarations">element
    declarations</a> (the allowed children within the type) and
    <a href="http://www.w3.org/TR/xmlschema-1/#cAttribute_Declarations">attribute
    declarations</a> which jointly define the structure of an element that is
    an instance of that complexType. Elsewhere, this type definition is then used
    to specify allowed named instances of it in other type definitions.
</p>
<p>
    <strong>has-a</strong> &mdash; Assuming a finite non-recursive 
    set of these definitions there must be a "top lattice" - the 
    <a href="<% paths.transform(schema.complexType('Nexml').url) %>"><em>Nexml 
    complexType</em></a>. Starting from this top level type 
    we can then navigate the schema by traversing the path of types allowed
    within other types. The way the documentation shows this is by listing,
    where applicable, the immediate substructures of the complex type. For
    example, the Nexml type allows one or more child elements of type Taxa,
    which in instance documents are implemented by elements called "otus".
    If we follow the link to the Taxa complex type we can have a look at what
    child elements are allowed in the "otus" element and follow the links to
    their type definitions and so on.
</p>
<p>
    <strong>is-a</strong> &mdash; Because the nexml schema is 
    designed in a modular way with named types, their type definitions can be
    reused and extended to derive other types. This is done extensively in the
    schema, and you can explore this inheritance tree by following the links
    in the <em>Inheritance</em> subsection of each type definition, which 
    specifies what superclass the type was derived from (and how, namely through
    restriction or extension) and what other types derive from this type.   
</p>